{"version":3,"file":"parse-config-file.js","sources":["../../node_modules/yaml/browser/dist/schema/common/map.js","../../node_modules/yaml/browser/dist/schema/common/seq.js","../../node_modules/yaml/browser/dist/schema/common/string.js","../../node_modules/yaml/browser/dist/schema/common/null.js","../../node_modules/yaml/browser/dist/schema/core/bool.js","../../node_modules/yaml/browser/dist/stringify/stringifyNumber.js","../../node_modules/yaml/browser/dist/schema/core/float.js","../../node_modules/yaml/browser/dist/schema/core/int.js","../../node_modules/yaml/browser/dist/schema/core/schema.js","../../node_modules/yaml/browser/dist/schema/json/schema.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/float.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/int.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js","../../node_modules/yaml/browser/dist/schema/tags.js","../../node_modules/yaml/browser/dist/schema/Schema.js","../../node_modules/yaml/browser/dist/stringify/stringifyDocument.js","../../node_modules/yaml/browser/dist/doc/Document.js","../../node_modules/yaml/browser/dist/errors.js","../../node_modules/yaml/browser/dist/compose/resolve-props.js","../../node_modules/yaml/browser/dist/compose/util-contains-newline.js","../../node_modules/yaml/browser/dist/compose/util-flow-indent-check.js","../../node_modules/yaml/browser/dist/compose/util-map-includes.js","../../node_modules/yaml/browser/dist/compose/resolve-block-map.js","../../node_modules/yaml/browser/dist/compose/resolve-block-seq.js","../../node_modules/yaml/browser/dist/compose/resolve-end.js","../../node_modules/yaml/browser/dist/compose/resolve-flow-collection.js","../../node_modules/yaml/browser/dist/compose/compose-collection.js","../../node_modules/yaml/browser/dist/compose/resolve-block-scalar.js","../../node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js","../../node_modules/yaml/browser/dist/compose/compose-scalar.js","../../node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js","../../node_modules/yaml/browser/dist/compose/compose-node.js","../../node_modules/yaml/browser/dist/compose/compose-doc.js","../../node_modules/yaml/browser/dist/compose/composer.js","../../node_modules/yaml/browser/dist/parse/line-counter.js","../../node_modules/yaml/browser/dist/parse/parser.js","../../node_modules/yaml/browser/dist/public-api.js","../../src/common/parse-config-file.ts"],"sourcesContent":["import { isMap } from '../../nodes/identity.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)\n};\n\nexport { map };\n","import { isSeq } from '../../nodes/identity.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)\n};\n\nexport { seq };\n","import { stringifyString } from '../../stringify/stringifyString.js';\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { string };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexport { nullTag };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexport { boolTag };\n","function stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = Object.is(value, -0) ? '-0' : JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexport { stringifyNumber };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intHex, intOct };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { boolTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intOct, int, intHex } from './int.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float\n];\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { map } from '../common/map.js';\nimport { seq } from '../common/seq.js';\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map, seq].concat(jsonScalars, jsonError);\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        type ?? (type = Scalar.BLOCK_LITERAL);\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nexport { falseTag, trueTag };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intBin, intHex, intOct };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\\.000Z$/, '') ?? ''\n};\n\nexport { floatTime, intTime, timestamp };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { binary } from './binary.js';\nimport { trueTag, falseTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intBin, intOct, int, intHex } from './int.js';\nimport { merge } from './merge.js';\nimport { omap } from './omap.js';\nimport { pairs } from './pairs.js';\nimport { set } from './set.js';\nimport { intTime, floatTime, timestamp } from './timestamp.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    merge,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nexport { schema };\n","import { map } from './common/map.js';\nimport { nullTag } from './common/null.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { boolTag } from './core/bool.js';\nimport { floatNaN, floatExp, float } from './core/float.js';\nimport { intOct, intHex, int } from './core/int.js';\nimport { schema } from './core/schema.js';\nimport { schema as schema$1 } from './json/schema.js';\nimport { binary } from './yaml-1.1/binary.js';\nimport { merge } from './yaml-1.1/merge.js';\nimport { omap } from './yaml-1.1/omap.js';\nimport { pairs } from './yaml-1.1/pairs.js';\nimport { schema as schema$2 } from './yaml-1.1/schema.js';\nimport { set } from './yaml-1.1/set.js';\nimport { timestamp, intTime, floatTime } from './yaml-1.1/timestamp.js';\n\nconst schemas = new Map([\n    ['core', schema],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema$2],\n    ['yaml-1.1', schema$2]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float,\n    floatExp,\n    floatNaN,\n    floatTime,\n    int,\n    intHex,\n    intOct,\n    intTime,\n    map,\n    merge,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:merge': merge,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge)\n            ? schemaTags.concat(merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexport { coreKnownTags, getTags };\n","import { MAP, SCALAR, SEQ } from '../nodes/identity.js';\nimport { map } from './common/map.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { getTags, coreKnownTags } from './tags.js';\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexport { Schema };\n","import { isNode } from '../nodes/identity.js';\nimport { createStringifyContext, stringify } from './stringify.js';\nimport { indentComment, lineComment } from './stringifyComment.js';\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexport { stringifyDocument };\n","import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n","class YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end?.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexport { YAMLError, YAMLParseError, YAMLWarning, prettifyError };\n","function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n","function containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport { containsNewline };\n","import { containsNewline } from './util-contains-newline.js';\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexport { flowIndentCheck };\n","import { isScalar } from '../nodes/identity.js';\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (isScalar(a) && isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexport { mapIncludes };\n","import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n","import { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveProps } from './resolve-props.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value?.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexport { resolveBlockSeq };\n","function resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexport { resolveEnd };\n","import { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source?.[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce?.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n","import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt?.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n","import { Scalar } from '../nodes/Scalar.js';\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexport { resolveBlockScalar };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n","import { isScalar, SCALAR } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n","function emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        pos ?? (pos = before.length);\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexport { emptyScalarPosition };\n","import { Alias } from '../nodes/Alias.js';\nimport { isScalar } from '../nodes/identity.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n","import { Document } from '../doc/Document.js';\nimport { composeNode, composeEmptyNode } from './compose-node.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexport { composeDoc };\n","import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n","/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexport { LineCounter };\n","import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && top?.type !== 'doc-end') {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (bv.type === 'block-seq') {\n                            if (!it.explicitKey &&\n                                it.sep &&\n                                !includesToken(it.sep, 'newline')) {\n                                yield* this.pop({\n                                    type: 'error',\n                                    offset: this.offset,\n                                    message: 'Unexpected block-seq-ind on same line with key',\n                                    source: this.source\n                                });\n                                return;\n                            }\n                        }\n                        else if (atMapIndent) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top?.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n","import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n","import { Config, configSchema } from 'src/types'\nimport { parse as yamlparse } from 'yaml'\n\nexport const parseConfigFile = async (configFile: string): Promise<Config> => {\n  return configSchema.parse(yamlparse(configFile))\n}\n"],"names":["map","schema","seq","floatNaN","floatExp","float","intIdentify","intResolve","intStringify","intOct","int","intHex","n","res","schema$2","tags","merge","composeNode","composeEmptyNode","isMap","CN","value","end","tag","start","yamlparse"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]}