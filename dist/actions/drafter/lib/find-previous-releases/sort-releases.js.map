{"version":3,"file":"sort-releases.js","sources":["../../../../../node_modules/compare-versions/index.mjs","../../../../../src/actions/drafter/lib/find-previous-releases/sort-releases.ts"],"sourcesContent":["export default function compareVersions(v1, v2) {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n}\n\nexport const validate = (v) =>\n  typeof v === 'string' && /^[v\\d]/.test(v) && semver.test(v);\n\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n\n  return operatorResMap[operator].includes(res);\n};\n\nexport const satisfies = (v, r) => {\n  // if no range operator then \"=\"\n  const m = r.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(v, r, op);\n\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3] = validateAndParse(v);\n  const [r1, r2, r3] = validateAndParse(r);\n  if (compareStrings(v1, r1) !== 0) return false;\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\n\n// export CJS style for parity\ncompareVersions.validate = validate;\ncompareVersions.compare = compare;\ncompareVersions.sastisfies = satisfies;\n\nconst semver =\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = (v) => {\n  if (typeof v !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = v.match(semver);\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${v}' received)`);\n  }\n  match.shift();\n  return match;\n};\n\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = (v) => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) =>\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || 0, b[i] || 0);\n    if (r !== 0) return r;\n  }\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1],\n};\n\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = (op) => {\n  if (typeof op !== 'string') {\n    throw new TypeError(\n      `Invalid operator type, expected string but got ${typeof op}`\n    );\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\n    );\n  }\n};\n","import { Config } from 'src/types'\nimport regexEscape from 'escape-string-regexp'\nimport compareVersions from 'compare-versions'\nimport { Octokit } from 'src/common/get-octokit'\n\nexport const sortReleases = (params: {\n  releases: Awaited<\n    ReturnType<Octokit['rest']['repos']['listReleases']>\n  >['data']\n  tagPrefix: Config['tag-prefix']\n}) => {\n  // For semver, we find the greatest release number\n  // For non-semver, we use the most recently merged\n  const tagPrefixRexExp = params.tagPrefix\n    ? new RegExp(`^${regexEscape(params.tagPrefix)}`)\n    : undefined\n\n  return params.releases.sort((r1, r2) => {\n    const tag_name_1 = tagPrefixRexExp\n      ? r1.tag_name.replace(tagPrefixRexExp, '')\n      : r1.tag_name\n    const tag_name_2 = tagPrefixRexExp\n      ? r2.tag_name.replace(tagPrefixRexExp, '')\n      : r2.tag_name\n\n    try {\n      return compareVersions(tag_name_1, tag_name_2)\n    } catch {\n      return (\n        new Date(r1.created_at).getTime() - new Date(r2.created_at).getTime()\n      )\n    }\n  })\n}\n"],"names":["regexEscape"],"mappings":"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","x_google_ignoreList":[0]}